<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Assessment - OneScript</title>
  <link rel="stylesheet" href="../styles.css">
</head>
<body>
  <div id="header"></div>

  <div class="container">
    <h1 class="page-title">Health Assessment</h1>
    <p class="page-subtitle" id="assessmentSubtitle">Please answer the following questions</p>

    <div class="card">
      <form id="assessmentForm">
        <div id="questionsContainer">
          <!-- Questions will be loaded dynamically here -->
        </div>

        <div id="blockingMessage" class="info-box" style="display: none; background-color: #FFEBEE; border-left: 4px solid var(--error);">
          <p style="color: var(--error); margin: 0;"><strong>⚠️ Unable to Proceed:</strong> <span id="blockingMessageText"></span></p>
        </div>

        <div class="info-box">
          <p><strong>Note:</strong> You can save your progress at any time. Incomplete assessments will be saved with "Incomplete" status.</p>
        </div>

        <div class="form-actions">
          <button type="button" class="btn-secondary" onclick="saveAssessmentProgress()">Save Progress</button>
          <button type="submit" class="btn-primary" id="submitBtn">Continue to Product Selection →</button>
        </div>
      </form>
    </div>
  </div>

  <div id="footer"></div>

  <script src="../js/app.js"></script>
  <script>
    let currentDisease = null;
    let allQuestions = [];
    let answers = {};
    let blockingReasons = [];

    // Get disease from URL or sessionStorage
    function getSelectedDisease() {
      const urlParams = new URLSearchParams(window.location.search);
      const diseaseId = urlParams.get('disease') || sessionStorage.getItem('selectedDisease');
      
      if (!diseaseId) {
        // Default to first disease or redirect
        const diseases = JSON.parse(localStorage.getItem('diseases') || '[]');
        if (diseases.length > 0) {
          return diseases[0].id;
        }
        return null;
      }
      return diseaseId;
    }

    // Load questions for selected disease
    function loadQuestions() {
      const diseaseId = getSelectedDisease();
      if (!diseaseId) {
        document.getElementById('questionsContainer').innerHTML = '<p style="text-align: center; color: var(--text-light); padding: 2rem;">No assessment available. Please select a service first.</p>';
        return;
      }

      const diseases = JSON.parse(localStorage.getItem('diseases') || '[]');
      currentDisease = diseases.find(d => d.id === diseaseId);
      
      if (!currentDisease || !currentDisease.questions || currentDisease.questions.length === 0) {
        document.getElementById('questionsContainer').innerHTML = '<p style="text-align: center; color: var(--text-light); padding: 2rem;">No questions available for this condition.</p>';
        return;
      }

      document.getElementById('assessmentSubtitle').textContent = `Please answer the following questions related to ${currentDisease.name}`;
      
      // Sort questions by order
      allQuestions = [...currentDisease.questions].sort((a, b) => (a.order || 999) - (b.order || 999));
      
      // Load saved answers
      const saved = localStorage.getItem(`assessment_${diseaseId}`);
      if (saved) {
        answers = JSON.parse(saved);
      }

      renderQuestions();
      checkBlockingConditions();
    }

    // Render questions based on current answers
    function renderQuestions() {
      const container = document.getElementById('questionsContainer');
      container.innerHTML = '';

      const visibleQuestions = getVisibleQuestions();

      if (visibleQuestions.length === 0) {
        container.innerHTML = '<p style="text-align: center; color: var(--text-light); padding: 2rem;">No questions to display.</p>';
        return;
      }

      visibleQuestions.forEach((question, index) => {
        const questionDiv = document.createElement('div');
        questionDiv.className = 'question-group';
        questionDiv.id = `question-${question.id}`;
        questionDiv.dataset.questionId = question.id;

        const label = document.createElement('label');
        label.className = 'question-label';
        label.textContent = `${index + 1}. ${question.text}`;
        questionDiv.appendChild(label);

        // Render based on question type
        if (question.type === 'multiple-choice' || question.type === 'yes-no') {
          const checkboxGroup = document.createElement('div');
          checkboxGroup.className = 'checkbox-group';
          
          question.options.forEach((option, optIndex) => {
            const optionDiv = document.createElement('div');
            optionDiv.className = 'checkbox-option';
            
            const input = document.createElement('input');
            input.type = 'radio';
            input.name = question.id;
            input.id = `${question.id}-${optIndex}`;
            input.value = option;
            input.required = true;
            
            // Set saved answer
            if (answers[question.id] === option) {
              input.checked = true;
            }
            
            input.addEventListener('change', function() {
              answers[question.id] = option;
              saveAnswers();
              // Check blocking first, then re-render
              const wasBlocked = blockingReasons.length > 0;
              checkBlockingConditions(true); // Show alert if blocked
              renderQuestions(); // Re-render to show/hide dependent questions
              // Re-check after rendering in case new questions have blocking conditions
              if (!wasBlocked) {
                checkBlockingConditions();
              }
            });
            
            const label = document.createElement('label');
            label.htmlFor = input.id;
            label.textContent = option;
            
            optionDiv.appendChild(input);
            optionDiv.appendChild(label);
            checkboxGroup.appendChild(optionDiv);
          });
          
          questionDiv.appendChild(checkboxGroup);
        } else if (question.type === 'multiple-select') {
          const checkboxGroup = document.createElement('div');
          checkboxGroup.className = 'checkbox-group';
          
          question.options.forEach((option, optIndex) => {
            const optionDiv = document.createElement('div');
            optionDiv.className = 'checkbox-option';
            
            const input = document.createElement('input');
            input.type = 'checkbox';
            input.id = `${question.id}-${optIndex}`;
            input.value = option;
            input.name = `${question.id}[]`;
            
            // Set saved answer
            if (answers[question.id] && Array.isArray(answers[question.id]) && answers[question.id].includes(option)) {
              input.checked = true;
            }
            
            input.addEventListener('change', function() {
              if (!answers[question.id]) answers[question.id] = [];
              if (input.checked) {
                if (!answers[question.id].includes(option)) {
                  answers[question.id].push(option);
                }
              } else {
                answers[question.id] = answers[question.id].filter(a => a !== option);
              }
              saveAnswers();
              // Check blocking first, then re-render
              const wasBlocked = blockingReasons.length > 0;
              checkBlockingConditions(true); // Show alert if blocked
              renderQuestions();
              // Re-check after rendering
              if (!wasBlocked) {
                checkBlockingConditions();
              }
            });
            
            const label = document.createElement('label');
            label.htmlFor = input.id;
            label.textContent = option;
            
            optionDiv.appendChild(input);
            optionDiv.appendChild(label);
            checkboxGroup.appendChild(optionDiv);
          });
          
          questionDiv.appendChild(checkboxGroup);
        } else if (question.type === 'text') {
          const input = document.createElement('input');
          input.type = 'text';
          input.className = 'form-input';
          input.name = question.id;
          input.required = true;
          input.value = answers[question.id] || '';
          input.addEventListener('input', function() {
            answers[question.id] = input.value;
            saveAnswers();
            checkBlockingConditions();
          });
          
          // Also check on blur for text inputs
          input.addEventListener('blur', function() {
            checkBlockingConditions(true);
          });
          questionDiv.appendChild(input);
        } else if (question.type === 'textarea') {
          const textarea = document.createElement('textarea');
          textarea.className = 'form-input';
          textarea.rows = 3;
          textarea.name = question.id;
          textarea.required = true;
          textarea.value = answers[question.id] || '';
          textarea.addEventListener('input', function() {
            answers[question.id] = textarea.value;
            saveAnswers();
            checkBlockingConditions();
          });
          
          // Also check on blur for textarea
          textarea.addEventListener('blur', function() {
            checkBlockingConditions(true);
          });
          questionDiv.appendChild(textarea);
        }

        container.appendChild(questionDiv);
      });
    }

    // Get visible questions based on dependencies
    function getVisibleQuestions() {
      const visible = [];
      const processed = new Set();
      
      // First pass: add questions with no dependencies
      allQuestions.forEach(question => {
        if (!question.dependsOn) {
          visible.push(question);
          processed.add(question.id);
        }
      });
      
      // Second pass: add dependent questions if conditions are met
      let changed = true;
      while (changed) {
        changed = false;
        allQuestions.forEach(question => {
          if (processed.has(question.id)) return;
          
          if (!question.dependsOn) {
            if (!visible.find(q => q.id === question.id)) {
              visible.push(question);
              processed.add(question.id);
              changed = true;
            }
            return;
          }

          // Check if dependency question is answered and visible
          const dependencyQuestion = visible.find(q => q.id === question.dependsOn);
          if (!dependencyQuestion) {
            return; // Dependency not visible yet
          }

          const dependencyAnswer = answers[question.dependsOn];
          if (!dependencyAnswer) {
            return; // Don't show if dependency not answered
          }

          // Check if answer matches conditional requirements
          let shouldShow = false;
          if (question.conditionalAnswers && question.conditionalAnswers.length > 0) {
            // For multiple-select, check if any selected answer matches
            if (Array.isArray(dependencyAnswer)) {
              shouldShow = dependencyAnswer.some(ans => question.conditionalAnswers.includes(ans));
            } else {
              // For single answer, check if it matches
              shouldShow = question.conditionalAnswers.includes(dependencyAnswer);
            }
          } else {
            // If no conditional answers specified, show if dependency is answered
            shouldShow = true;
          }

          if (shouldShow && !visible.find(q => q.id === question.id)) {
            visible.push(question);
            processed.add(question.id);
            changed = true;
          }
        });
      }

      // Sort visible questions by order
      visible.sort((a, b) => (a.order || 999) - (b.order || 999));
      
      return visible;
    }

    // Check blocking conditions
    function checkBlockingConditions(showAlert = false) {
      blockingReasons = [];
      
      allQuestions.forEach(question => {
        if (!question.blockingConditions || question.blockingConditions.length === 0) {
          return;
        }

        question.blockingConditions.forEach(condition => {
          const answer = answers[condition.questionId];
          if (answer) {
            // Check if answer matches blocking condition
            let isBlocked = false;
            if (Array.isArray(answer)) {
              isBlocked = answer.includes(condition.answer);
            } else {
              isBlocked = answer === condition.answer;
            }
            
            if (isBlocked) {
              const q = allQuestions.find(q => q.id === condition.questionId);
              const reason = `Your answer "${condition.answer}" to "${q ? q.text : 'question'}" prevents you from proceeding with this assessment.`;
              blockingReasons.push(reason);
              
              // Show alert if blocking condition is triggered
              if (showAlert) {
                alert(`⚠️ Cannot Proceed\n\n${reason}\n\nPlease contact a healthcare provider for further assistance.`);
              }
            }
          }
        });
      });

      const blockingDiv = document.getElementById('blockingMessage');
      const submitBtn = document.getElementById('submitBtn');
      
      if (blockingReasons.length > 0) {
        blockingDiv.style.display = 'block';
        document.getElementById('blockingMessageText').textContent = blockingReasons.join(' ');
        submitBtn.disabled = true;
        submitBtn.style.opacity = '0.5';
        submitBtn.style.cursor = 'not-allowed';
      } else {
        blockingDiv.style.display = 'none';
        submitBtn.disabled = false;
        submitBtn.style.opacity = '1';
        submitBtn.style.cursor = 'pointer';
      }
    }

    // Save answers
    function saveAnswers() {
      const diseaseId = getSelectedDisease();
      if (diseaseId) {
        localStorage.setItem(`assessment_${diseaseId}`, JSON.stringify(answers));
      }
    }

    // Handle form submission
    document.getElementById('assessmentForm').addEventListener('submit', function(e) {
      e.preventDefault();
      
      // Final check for blocking conditions
      checkBlockingConditions(true);
      
      if (blockingReasons.length > 0) {
        return;
      }

      // Save final answers
      const diseaseId = getSelectedDisease();
      if (diseaseId) {
        localStorage.setItem(`assessment_${diseaseId}`, JSON.stringify(answers));
        localStorage.setItem('lastAssessment', JSON.stringify({
          diseaseId: diseaseId,
          answers: answers,
          timestamp: new Date().toISOString()
        }));
      }

      // Redirect to product selection
      window.location.href = 'product-selection.html';
    });

    // Save progress
    function saveAssessmentProgress() {
      saveAnswers();
      alert('Progress saved! You can continue later.');
    }

    // Initialize
    loadQuestions();
  </script>
</body>
</html>


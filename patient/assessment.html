<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Assessment - OneScript</title>
  <link rel="stylesheet" href="../styles.css">
</head>
<body>
  <div id="header"></div>

  <div class="container">
    <h1 class="page-title">Health Assessment</h1>
    <p class="page-subtitle" id="assessmentSubtitle">Please answer the following questions</p>

    <div class="card">
      <form id="assessmentForm">
        <div id="questionsContainer">
          <!-- Questions will be loaded dynamically here -->
        </div>

        <div id="blockingMessage" class="info-box" style="display: none; background-color: #FFEBEE; border-left: 4px solid var(--error);">
          <p style="color: var(--error); margin: 0;"><strong>⚠️ Unable to Proceed:</strong> <span id="blockingMessageText"></span></p>
        </div>

        <div class="info-box">
          <p><strong>Note:</strong> You can save your progress at any time. Incomplete assessments will be saved with "Incomplete" status.</p>
        </div>

        <div class="form-actions">
          <button type="button" class="btn-secondary" onclick="saveAssessmentProgress()">Save Progress</button>
          <button type="submit" class="btn-primary" id="submitBtn">Continue to Product Selection →</button>
        </div>
      </form>
    </div>
  </div>

  <div id="footer"></div>

  <script src="../js/app.js"></script>
  <script>
    let currentDisease = null;
    let allQuestions = [];
    let answers = {};
    let blockingReasons = [];

    // Get disease from URL or sessionStorage
    function getSelectedDisease() {
      const urlParams = new URLSearchParams(window.location.search);
      const diseaseId = urlParams.get('disease') || sessionStorage.getItem('selectedDisease');
      
      if (!diseaseId) {
        // Default to first disease or redirect
        const diseases = JSON.parse(localStorage.getItem('diseases') || '[]');
        if (diseases.length > 0) {
          return diseases[0].id;
        }
        return null;
      }
      return diseaseId;
    }

    // Load questions for selected disease
    function loadQuestions() {
      const diseaseId = getSelectedDisease();
      if (!diseaseId) {
        document.getElementById('questionsContainer').innerHTML = '<p style="text-align: center; color: var(--text-light); padding: 2rem;">No assessment available. Please select a service first.</p>';
        return;
      }

      const diseases = JSON.parse(localStorage.getItem('diseases') || '[]');
      currentDisease = diseases.find(d => d.id === diseaseId);
      
      if (!currentDisease || !currentDisease.questions || currentDisease.questions.length === 0) {
        document.getElementById('questionsContainer').innerHTML = '<p style="text-align: center; color: var(--text-light); padding: 2rem;">No questions available for this condition.</p>';
        return;
      }

      document.getElementById('assessmentSubtitle').textContent = `Please answer the following questions related to ${currentDisease.name}`;
      
      // Sort questions by order
      allQuestions = [...currentDisease.questions].sort((a, b) => (a.order || 999) - (b.order || 999));
      
      // Load saved answers
      const saved = localStorage.getItem(`assessment_${diseaseId}`);
      if (saved) {
        answers = JSON.parse(saved);
      }

      renderQuestions();
      checkBlockingConditions();
    }

    // Render questions based on current answers
    function renderQuestions() {
      const container = document.getElementById('questionsContainer');
      container.innerHTML = '';

      const visibleQuestions = getVisibleQuestions();

      if (visibleQuestions.length === 0) {
        container.innerHTML = '<p style="text-align: center; color: var(--text-light); padding: 2rem;">No questions to display.</p>';
        return;
      }

      visibleQuestions.forEach((question, index) => {
        const questionDiv = document.createElement('div');
        questionDiv.className = 'question-group';
        questionDiv.id = `question-${question.id}`;
        questionDiv.dataset.questionId = question.id;

        const label = document.createElement('label');
        label.className = 'question-label';
        label.textContent = `${index + 1}. ${question.text}${question.required !== false ? ' *' : ''}`;
        questionDiv.appendChild(label);
        
        // Add question description if it exists
        if (question.description) {
          const desc = document.createElement('p');
          desc.style.cssText = 'font-size: 0.9rem; color: var(--text-light); margin: 0.25rem 0 0.75rem 0; font-style: italic;';
          desc.textContent = question.description;
          questionDiv.appendChild(desc);
        }

        // Render based on question type
        if (question.type === 'multiple-choice' || question.type === 'yes-no') {
          const checkboxGroup = document.createElement('div');
          checkboxGroup.className = 'checkbox-group';
          
          question.options.forEach((option, optIndex) => {
            const optionDiv = document.createElement('div');
            optionDiv.className = 'checkbox-option';
            
            const input = document.createElement('input');
            input.type = 'radio';
            input.name = question.id;
            input.id = `${question.id}-${optIndex}`;
            input.value = option;
            input.required = question.required !== false;
            
            // Set saved answer
            if (answers[question.id] === option) {
              input.checked = true;
            }
            
            input.addEventListener('change', function() {
              answers[question.id] = option;
              saveAnswers();
              // Check blocking first, then re-render
              const wasBlocked = blockingReasons.length > 0;
              checkBlockingConditions(true); // Show alert if blocked
              renderQuestions(); // Re-render to show/hide dependent questions
              // Re-check after rendering in case new questions have blocking conditions
              if (!wasBlocked) {
                checkBlockingConditions();
              }
            });
            
            const label = document.createElement('label');
            label.htmlFor = input.id;
            label.textContent = option;
            
            optionDiv.appendChild(input);
            optionDiv.appendChild(label);
            checkboxGroup.appendChild(optionDiv);
          });
          
          questionDiv.appendChild(checkboxGroup);
        } else if (question.type === 'multiple-select') {
          const checkboxGroup = document.createElement('div');
          checkboxGroup.className = 'checkbox-group';
          
          question.options.forEach((option, optIndex) => {
            const optionDiv = document.createElement('div');
            optionDiv.className = 'checkbox-option';
            
            const input = document.createElement('input');
            input.type = 'checkbox';
            input.id = `${question.id}-${optIndex}`;
            input.value = option;
            input.name = `${question.id}[]`;
            
            // Set saved answer
            if (answers[question.id] && Array.isArray(answers[question.id]) && answers[question.id].includes(option)) {
              input.checked = true;
            }
            
            input.addEventListener('change', function() {
              if (!answers[question.id]) answers[question.id] = [];
              if (input.checked) {
                if (!answers[question.id].includes(option)) {
                  answers[question.id].push(option);
                }
              } else {
                answers[question.id] = answers[question.id].filter(a => a !== option);
              }
              saveAnswers();
              // Check blocking first, then re-render
              const wasBlocked = blockingReasons.length > 0;
              checkBlockingConditions(true); // Show alert if blocked
              renderQuestions();
              // Re-check after rendering
              if (!wasBlocked) {
                checkBlockingConditions();
              }
            });
            
            const label = document.createElement('label');
            label.htmlFor = input.id;
            label.textContent = option;
            
            optionDiv.appendChild(input);
            optionDiv.appendChild(label);
            checkboxGroup.appendChild(optionDiv);
          });
          
          questionDiv.appendChild(checkboxGroup);
        } else if (question.type === 'text') {
          const input = document.createElement('input');
          input.type = 'text';
          input.className = 'form-input';
          input.name = question.id;
          input.required = true;
          input.value = answers[question.id] || '';
          input.addEventListener('input', function() {
            answers[question.id] = input.value;
            saveAnswers();
            checkBlockingConditions();
          });
          
          // Also check on blur for text inputs
          input.addEventListener('blur', function() {
            checkBlockingConditions(true);
          });
          questionDiv.appendChild(input);
        } else if (question.type === 'textarea') {
          const textarea = document.createElement('textarea');
          textarea.className = 'form-input';
          textarea.rows = 3;
          textarea.name = question.id;
          textarea.required = true;
          textarea.value = answers[question.id] || '';
          textarea.addEventListener('input', function() {
            answers[question.id] = textarea.value;
            saveAnswers();
            checkBlockingConditions();
          });
          
          // Also check on blur for textarea
          textarea.addEventListener('blur', function() {
            checkBlockingConditions(true);
          });
          questionDiv.appendChild(textarea);
        }

        container.appendChild(questionDiv);
      });
    }

    // Check if all dependencies are met for a question
    function checkDependencies(question) {
      // If no dependencies, always show
      if (!question.dependencies || question.dependencies.length === 0) {
        return true;
      }

      // Check ALL dependencies (AND logic)
      return question.dependencies.every(dep => {
        const dependencyQuestion = allQuestions.find(q => q.id === dep.questionId);
        if (!dependencyQuestion) {
          return false; // Dependency question doesn't exist
        }

        const dependencyAnswer = answers[dep.questionId];
        if (!dependencyAnswer) {
          return false; // Dependency not answered
        }

        // Check if answer matches requirement
        if (dep.answer === '*') {
          // Any answer is acceptable for text/textarea
          return true;
        }

        if (Array.isArray(dependencyAnswer)) {
          // For multiple-select, check if any selected answer matches
          return dependencyAnswer.includes(dep.answer);
        } else {
          // For single answer, check if it matches exactly
          return dependencyAnswer === dep.answer;
        }
      });
    }

    // Check if dependency questions are visible
    function areDependencyQuestionsVisible(question) {
      if (!question.dependencies || question.dependencies.length === 0) {
        return true;
      }

      // Check if all dependency questions are visible (recursively)
      return question.dependencies.every(dep => {
        const depQuestion = allQuestions.find(q => q.id === dep.questionId);
        if (!depQuestion) return false;
        
        // If dependency has no dependencies, it's visible
        if (!depQuestion.dependencies || depQuestion.dependencies.length === 0) {
          return true;
        }
        
        // Recursively check if dependency's dependencies are visible
        return areDependencyQuestionsVisible(depQuestion);
      });
    }

    // Get visible questions based on dependencies
    function getVisibleQuestions() {
      const visible = [];
      const processed = new Set();
      
      // First pass: add questions with no dependencies
      allQuestions.forEach(question => {
        if (!question.dependencies || question.dependencies.length === 0) {
          visible.push(question);
          processed.add(question.id);
        }
      });
      
      // Iterate until no more questions can be added
      let changed = true;
      let maxIterations = 100; // Safety limit
      let iterations = 0;
      
      while (changed && iterations < maxIterations) {
        changed = false;
        iterations++;
        
        allQuestions.forEach(question => {
          if (processed.has(question.id)) return;
          
          // Check if all dependency questions are visible
          if (!areDependencyQuestionsVisible(question)) {
            return; // Dependencies not visible yet
          }

          // Check if all dependencies are met
          if (checkDependencies(question)) {
            visible.push(question);
            processed.add(question.id);
            changed = true;
          }
        });
      }

      // Sort visible questions by order
      visible.sort((a, b) => (a.order || 999) - (b.order || 999));
      
      return visible;
    }

    // Check blocking conditions
    function checkBlockingConditions(showAlert = false) {
      blockingReasons = [];
      
      allQuestions.forEach(question => {
        if (!question.blockingConditions || question.blockingConditions.length === 0) {
          return;
        }

        question.blockingConditions.forEach(condition => {
          const answer = answers[condition.questionId];
          if (answer) {
            // Check if answer matches blocking condition
            let isBlocked = false;
            if (Array.isArray(answer)) {
              isBlocked = answer.includes(condition.answer);
            } else {
              isBlocked = answer === condition.answer;
            }
            
            if (isBlocked) {
              const q = allQuestions.find(q => q.id === condition.questionId);
              const reason = `Your answer "${condition.answer}" to "${q ? q.text : 'question'}" prevents you from proceeding with this assessment.`;
              blockingReasons.push(reason);
              
              // Show alert if blocking condition is triggered
              if (showAlert) {
                alert(`⚠️ Cannot Proceed\n\n${reason}\n\nPlease contact a healthcare provider for further assistance.`);
              }
            }
          }
        });
      });

      const blockingDiv = document.getElementById('blockingMessage');
      const submitBtn = document.getElementById('submitBtn');
      
      if (blockingReasons.length > 0) {
        blockingDiv.style.display = 'block';
        document.getElementById('blockingMessageText').textContent = blockingReasons.join(' ');
        submitBtn.disabled = true;
        submitBtn.style.opacity = '0.5';
        submitBtn.style.cursor = 'not-allowed';
      } else {
        blockingDiv.style.display = 'none';
        submitBtn.disabled = false;
        submitBtn.style.opacity = '1';
        submitBtn.style.cursor = 'pointer';
      }
    }

    // Save answers
    function saveAnswers() {
      const diseaseId = getSelectedDisease();
      if (diseaseId) {
        localStorage.setItem(`assessment_${diseaseId}`, JSON.stringify(answers));
      }
    }

    // Handle form submission
    document.getElementById('assessmentForm').addEventListener('submit', function(e) {
      e.preventDefault();
      
      // Final check for blocking conditions
      checkBlockingConditions(true);
      
      if (blockingReasons.length > 0) {
        return;
      }

      // Save final answers
      const diseaseId = getSelectedDisease();
      if (diseaseId) {
        localStorage.setItem(`assessment_${diseaseId}`, JSON.stringify(answers));
        localStorage.setItem('lastAssessment', JSON.stringify({
          diseaseId: diseaseId,
          answers: answers,
          timestamp: new Date().toISOString()
        }));
      }

      // Redirect to product selection
      window.location.href = 'product-selection.html';
    });

    // Save progress - override the one from app.js for this page
    function saveAssessmentProgress() {
      saveAnswers();
      alert('Progress saved! You can continue later.');
    }
    window.saveAssessmentProgress = saveAssessmentProgress;

    // Initialize
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', loadQuestions);
    } else {
      loadQuestions();
    }
  </script>
</body>
</html>

